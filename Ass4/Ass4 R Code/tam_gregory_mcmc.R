#1.4
library(MASS)
library(coda)

impala = read.table("impala.txt", header = TRUE)
impala = impala[,1]

waterbuck = read.table("waterbuck.txt", header = TRUE)
waterbuck = waterbuck[,1]

kBound = 150
kMu = 5
kTheta = 0.6
kLambda = kTheta * kMu

sample.data <- function(n)
{
  N = rpois(1,kMu)
  Y = rbinom(n, N, kTheta)
}

log.lik <- function(Y, N, theta)
{
  # Log-likelihood of the data
  sum(dbinom(Y, N, theta, log=T))
}

log.prior <- function(N, theta)
{
  #1/N times the indicator that theta is in [0,1]
  log(1/N * ifelse(theta>=0 & theta<=1,1,0))
}

log.posterior <- function(Y, N, theta)
{
  log.lik(Y, N, theta) + log.prior(N, theta)
}

mle <- function(y)
{
  # Example code to compute the MLE given the data
  # 
  # Args:
  #   y = vector of values (generated by sample.data)
  # Example:
  #   y = sample.data(100)
  #   mle(y)
  f <- function(par)
  {
    #adds floor function since N must be a positive integer
    log.lik(y, floor(par[1]), par[2])
  }
  x = optim(par=c(max(y),0.5), fn=f, control=list(fnscale=-1),
            method="L-BFGS-B", lower=c(max(y), 1e-10), upper = c(Inf,1-1e-10))
  print(sprintf("Log-likelihood=%.3f", x$value))
  return(x$par)
}


plot.posterior.density <- function(data, overlay=FALSE, graph.length=200)
{
  # Plots the density of the posterior density with contour lines.
  #
  # Args:
  #   data = vector of values (generated by sample.data)
  # Example:
  #   y = sample.data(100)
  #   explore.posterior.density(y)
  N = seq(max(data), max(data)+graph.length, by=1)
  theta = seq(0,1,length.out=length(N)+2)
  theta = theta[-length(theta)][-1]
  gr = expand.grid(x=N, y=theta)
  z = apply(gr, 1, function(par) log.lik(data, par[1], par[2]))
  z = matrix(z, nrow=length(N), ncol=length(theta))
  print("Summary of likelihood values.")
  print(summary(exp(as.vector(z))))
  z0 = quantile(z, probs = c(0.1))
  z1 = max(z)
  ncols = 10000
  cols = topo.colors(ncols)
  i = apply(gr, 1, function(par) {
    ll = log.posterior(data, par[1], par[2])
    if(ll < z0) return(0)
    return((ll - z0) / (z1 - z0))
  })
  par(mfrow=c(1, 1))
  # hist(i)
  j = ncols * i
  j[j==0] <- 1
  if(overlay==FALSE)
    plot(gr[,1], gr[,2], xlab="N", ylab="theta", col=cols[j], pch=".", cex=4)
  contour(N, theta, z, nlevels = 50, add=T, cex=2, col="black")
}

explore.log.lik <- function(data, ndraws=1e4)
{
  # Simply tries random values for (a, b) and computes the likelihood.
  #
  random.par <- function()
  {
    return(runif(2, min=1e-4, max=20))
  }  
  mPar = t(replicate(ndraws, { random.par() }))
  z = apply(mPar, 1, function(row) log.lik(row[1], row[2], data))
  mPar = cbind(mPar, z)
  # order by increasing likelihood
  mPar = mPar[rev(order(z)), ]
}

plot.chain <- function(mcmc.chain)
{
  mcmc.niters = nrow(mcmc.chain)
  burnin = 0.1 * mcmc.niters
  mcmc.chain = mcmc.chain[burnin:mcmc.niters, ]
  f = kde2d(x=mcmc.chain[, 1], y=mcmc.chain[, 2], n=100)
  image(f, xlim=range(mcmc.chain[,1]), ylim=range(mcmc.chain[,2]), xlab="N", ylab="theta")
}


mcmc.mh <- function(y, mcmc.niters=1e4, N.bound, N.init, theta.init)
{
  # Complete with MH.
  S = sum(y)
  n = length(y)
  mcmc.chain <- matrix(, nrow=mcmc.niters, ncol=2)
  mcmc.chain[1,]=c(N.init, theta.init)
  nacc <- 0
  for(i in 2:mcmc.niters)
  {
    # 1. Current state
    N.old = mcmc.chain[i-1, 1]
    theta.old = mcmc.chain[i-1, 2]
    # 2. Propose new state
    #Sample new N
    repeat
    {      
      #geometric over entire thing
        N.new = rgeom(1,1/(1+N.old))
      #only keep sample if N is in the boundaries
      if(N.new >= max(y) & N.new<=N.bound)
        break
    }
    #Sample new NTheta, then infer new theta
    repeat
    {
      #sample theta from Beta
      M.new = N.old * rbeta(1, shape1 = S+1, shape2 = n*N.old-S+1)
      theta.new = M.new/N.new
      #only keep theta if it is valid
      if(theta.new>=0 && theta.new<=1)
        break
    }
    
    # 3. Ratio
    mh.ratio = min(0, log.posterior(y,N.new,theta.new) - 
                     log.posterior(y,N.old,theta.old))
    if(runif(1) < exp(mh.ratio)) {
      # Accept 
      mcmc.chain[i, ] <- c(N.new, theta.new)
      nacc <- nacc + 1
    } else {
      mcmc.chain[i, ] <- c(N.old, theta.old)
    }
  }
  # Cut the burnin period.
  print(sprintf("Acceptance ratio %.2f%%", 100 * nacc / mcmc.niters))
  plot.chain(mcmc.chain)
  return(list("chain"=mcmc.chain, "accept" = 100 * nacc / mcmc.niters))
}

y = waterbuck
param = cbind(c(rep(max(y),5), rep(max(y)+10,5)),c(rep(c(0.1,0.3,0.5,0.7,0.9),2)))
#prob that N>100
waterbuck.prob=c()
for(i in 1:10)
{
  waterbuck.sample = mcmc.mh(y, mcmc.niters=1e5, N.bound=200, N.init=param[i,1], theta.init=param[i,2])  
  N = waterbuck.sample$chain[,1]
  theta = waterbuck.sample$chain[,2]
  burnin = length(N)*0.1
  N = N[burnin:length(N)]
  theta = theta[burnin:length(theta)]
  
  png(paste("Stat221Waterbuck",i,".png",sep=""), width = 600, height = 400)
  par(mar=c(5,5,3,3))
  plot(N,theta,main=paste(sep="","N=",param[i,1], "  theta=",param[i,2]),cex.main=3,cex.lab=2.5,cex.axis=2)
  plot.posterior.density(y,overlay=TRUE,graph.length=200)
  dev.off()
  waterbuck.prob[i] = length(which(N>100))/length(N)
}

png(paste("Stat221WaterbuckDiag.png"),width=600,height=600)
par(mfrow=c(2,2))
acf(N, main="ACF for N")
acf(theta, main="ACF for theta")
plot(N,type='l',main="Traceplot for N")
plot(theta,type='l',main="Traceplot for theta")
dev.off()

y = impala
param = cbind(c(rep(max(y),5), rep(max(y)+10,5)),c(rep(c(0.1,0.3,0.5,0.7,0.9),2)))
#prob that N>100
impala.prob=c()
for(i in 1:10)
{
  impala.sample = mcmc.mh(y, mcmc.niters=1e5, N.bound=200, N.init=param[i,1], theta.init=param[i,2])  
  N = impala.sample$chain[,1]
  theta = impala.sample$chain[,2]
  burnin = length(N)*0.1
  N = N[burnin:length(N)]
  theta = theta[burnin:length(theta)]
  
  png(paste("Stat221Impala",i,".png",sep=""), width = 600, height = 400)
  plot(N,theta,main=paste(sep="","N=",param[i,1], "  theta=",param[i,2]),cex.main=3,cex.lab=2.5,cex.axis=2)
  plot.posterior.density(y,overlay=TRUE,graph.length=200)
  dev.off()
  impala.prob[i] = length(which(N>100))/length(N)
}

png(paste("Stat221ImpalaDiag.png"),width=600,height=600)
par(mfrow=c(2,2))
acf(N)
acf(theta)
plot(N,type='l',main=paste("N ", impala.sample$accept, "%"))
plot(theta,type='l',main="theta")
dev.off()


