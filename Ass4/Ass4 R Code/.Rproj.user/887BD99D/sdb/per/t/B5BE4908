{
    "contents" : "## Metropolis-Hastings and convergence\n## Fall, 2014, Panos Toulis ptoulis@fas.harvard.edu\n## \nlibrary(mvtnorm)\nlibrary(coda)\nd = 5  # dimensions\nmu.vector <- c(1:d)\nrho = 0.5  # autocorrelation between components\nSigma <- (1-rho) * diag(d) + rho * matrix(1, nrow=d, ncol=d)\n# We will sample from \n# y ~ N(m, S)  where m = (1, 2, 3...d)  and S = r I + (1-r) U  i.e., equicorrelation\n\nNormalMHExample<-function(mcmc.niters, oracle=F)\n{\n  # Runs Metropolis-Hastings for the MVN example\n  # Returns  sims x d  matrix with samples.\n  #\n  # Use oracle=T if you need \"perfect sampling\"\n  #\n  # the chain matrix\n  theta.mh <- matrix(0, nrow = mcmc.niters, ncol = d)\n  # Start from overdispersed\n  theta.mh[1, ] <- rmvnorm(n=1, mean=mu.vector, sigma=2 * Sigma)\n  pb = txtProgressBar(style=3)\n  \n  nacc <- 0  # count of acceptance\n  for (i in 2:mcmc.niters)\n  {\n    # 1. Get current state of the chain\n    theta.old <- theta.mh[i-1,]  # prev parameters\n    # 2. Propose new state (theta.new)\n    if(oracle) {\n      # Here we sample from the actual distribution. \n      # We do this to check the effectiveness of the convergence checks.\n      theta.new <- rmvnorm(n=1, mean=mu.vector, sigma=Sigma)\n    } else {\n      # Propose  theta.new ~ N(theta.old, s * I)  i.e., around the current state\n      theta.new <- rmvnorm(n=1, mean=theta.old, sigma=2 * diag(d))  # new params\n    }\n    setTxtProgressBar(pb, value=i/mcmc.niters)\n    # 3. Compute MH ratio (the terms from the propNoosal cancel out by symmetry)\n    log.a = min(0, dmvnorm(theta.new, mean=mu.vector, sigma=Sigma, log=T) - \n                  dmvnorm(theta.old, mean=mu.vector, sigma=Sigma, log=T))\n    # 4. accept-reject\n    if(runif(1) < exp(log.a)) {\n      theta.mh[i,] <- theta.new\n      nacc <- nacc + 1\n    } else {\n      theta.mh[i,] <- theta.old\n    }\n  }\n  # 5. (optional) Print some statistics to make sure it is fine.\n  print(sprintf(\"Acceptance rate %.2f%%\", 100 * nacc/mcmc.niters))\n  burnin = 0.3 * mcmc.niters\n  return(theta.mh[-c(1:burnin),])\n}\n\n# Run the chain\nrun.chain <- function(show.diagnostics=F, oracle=F)\n{\n  mh.draws <- NormalMHExample(mcmc.niters = 5000, oracle=oracle)\n  \n  ##  Do the diagnostics here.\n  if (show.diagnostics)\n  {\n    library(coda)\n    mcmc.chain <- mcmc(mh.draws)\n    fns <- c(\"summary\", \"plot\", \"autocorr.plot\", \"rejectionRate\")\n    for (fn in fns)\n    {\n      readline(sprintf(\"Press [ENTER] for %s\", fn))\n      do.call(fn, args=list(mcmc.chain))\n    }\n  }\n  print(\"Geweke diagnostic\")\n  print(geweke.diag(mh.draws))\n  \n  print(\"Raftery diagnostic\")\n  print(raftery.diag(mh.draws, r=0.005))\n  \n  print(\"Heidelberg diagnostic\")\n  print(heidel.diag(mh.draws))\n}\n\nrubin.gelman <- function(nchains=5)\n{\n  mh.list <- list()\n  print(\"Calculating Gelman-Rubin diag\")\n  pb = txtProgressBar(style=3)\n  for(i in 1:nchains)\n  {\n    mh.list[[i]] <- mcmc(NormalMHExample(mcmc.niters = 2000, oracle = F))\n    setTxtProgressBar(pb, value=i/nchains)\n  }\n  mh.list <- mcmc.list(mh.list)\n  print(gelman.diag(mh.list))\n}\n\n\ny = sample.data(100)\nplot.posterior.density(y) \n\n\n",
    "created" : 1414891801560.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "6778332",
    "id" : "B5BE4908",
    "lastKnownWriteTime" : 1414891984,
    "path" : "~/Documents/School/Harvard/Third Semester/STAT 221/Assignments/Ass4/Ass4 R Code/mcmc_convergence.R",
    "project_path" : "mcmc_convergence.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}