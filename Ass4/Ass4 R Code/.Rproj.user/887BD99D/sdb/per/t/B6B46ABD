{
    "contents" : "# Panos Toulis, ptoulis@fas.harvard.edu\n# Section on MCMC\n# Fall 2014, Stat221, Harvard\n\n#\n# y ~ Pois(n, a * b), where a, b  in [0, 10]\n#\nrm(list=ls())\nlibrary(MASS)\nkBound = 150\nkAlpha = 5\nkBeta = 4\n\nsample.data <- function(n)\n{\n  rpois(n, lambda = kAlpha * kBeta)\n}\n\nlog.lik <- function(a, b, Y)\n{\n  # Log-likelihood of the data\n  sum(dpois(Y, lambda=a*b, log=T))\n}\n\nlog.prior <- function(a, b)\n{\n  # No prior for this model (could use something like an Expo -- see below)\n  return(0)\n  # return(dexp(a, rate=10, log=T))\n}\n\nlog.posterior <- function(a, b, Y)\n{\n  log.lik(a, b, Y) + log.prior(a, b)\n}\n\nmle <- function(y)\n{\n  # Example code to compute the MLE given the data\n  # Note: The model y ~ Pois(a * b) is misspecified so there are \n  #   multiple MLEs.\n  # \n  # Args:\n  #   y = vector of values (generated by sample.data)\n  # Example:\n  #   y = sample.data(100)\n  #   mle(y)\n  f <- function(par)\n  {\n    log.lik(par[1], par[2], y)\n  }\n  x = optim(par=c(0.2,0.6), fn=f, control=list(fnscale=-1), \n            method=\"L-BFGS-B\", lower=c(1e-3, 1e-3))\n  print(sprintf(\"Log-likelihood=%.3f\", x$value))\n  return(x$par)\n}\n\n\nplot.posterior.density <- function(data)\n{\n  # Plots the density of the posterior density with contour lines.\n  #\n  # Args:\n  #   data = vector of values (generated by sample.data)\n  # Example:\n  #   y = sample.data(100)\n  #   explore.posterior.density(y)\n  a = seq(.1, kBound, length.out=400)\n  b = a\n  gr = expand.grid(x=a, y=b)\n  z = apply(gr, 1, function(par) log.lik(par[1], par[2], data))\n  z = matrix(z, nrow=length(a), ncol=length(b))\n  print(\"Summary of likelihood values.\")\n  print(summary(as.vector(z)))\n  print(\"log-likelihood of the true parameter values\")\n  print(log.lik(kAlpha, kBeta, data))\n  z0 = quantile(z, probs = c(0.1))\n  z1 = max(z)\n  ncols = 10000\n  cols = topo.colors(ncols)\n  i = apply(gr, 1, function(par) {\n    ll = log.posterior(par[1], par[2], data)\n    if(ll < z0) return(0)\n    return((ll - z0) / (z1 - z0))\n  })\n  par(mfrow=c(1, 1))\n  # hist(i)\n  j = ncols * i\n  j[j==0] <- 1\n  plot(gr[,1], gr[,2], xlab=\"a\", ylab=\"b\", col=cols[j], pch=\".\", cex=4)\n  contour(a, b, z, nlevels = 50, add=T, cex=2, col=\"black\")\n  points(c(kAlpha), c(kBeta), pch=\"x\", cex=2.5)\n  lines(a, kAlpha * kBeta / a, col=\"red\")\n}\n\nexplore.log.lik <- function(data, ndraws=1e4)\n{\n  # Simply tries random values for (a, b) and computes the likelihood.\n  #\n  random.par <- function()\n  {\n    return(runif(2, min=1e-4, max=20))\n  }  \n  mPar = t(replicate(ndraws, { random.par() }))\n  z = apply(mPar, 1, function(row) log.lik(row[1], row[2], data))\n  mPar = cbind(mPar, z)\n  # order by increasing likelihood\n  mPar = mPar[rev(order(z)), ]\n}\n\nrgamma.trunc <- function(upper.bound, s, r)\n{\n  # Sample from truncated gamma. \n  # TODO: Find a better implementation.\n  x <- upper.bound + 10\n  while(x > upper.bound)\n  {\n    x = rgamma(1, shape=s, rate=r)\n  }\n  return(x)\n}\n\nplot.chain <- function(mcmc.chain)\n{\n  mcmc.niters = nrow(mcmc.chain)\n  burnin = 0.1 * mcmc.niters\n  mcmc.chain = mcmc.chain[burnin:mcmc.niters, ]\n  f = kde2d(x=mcmc.chain[, 1], y=mcmc.chain[, 2], n=100)\n  image(f, xlim=c(0, kBound), ylim=c(0, kBound))\n}\n\nmcmc.gibbs <- function(y, mcmc.niters=1e4)\n{\n  # Runs Gibbs on the data y\n  S = sum(y)  # sufficient statistic\n  n = length(y)\n  \n  mcmc.chain <- matrix(3, nrow=mcmc.niters, ncol=2)\n  \n  for(i in 2:mcmc.niters)\n  {\n    beta.last <- mcmc.chain[i-1, 2]\n    # Conditionals are truncated gammas.\n    alpha <- rgamma.trunc(kBound, s=S+1, r=n * beta.last)\n    beta <- rgamma.trunc(kBound, s=S+1,  r=n * alpha)\n    mcmc.chain[i, ] <- c(alpha, beta)\n  }\n  # Plot empirical density\n  plot.chain(mcmc.chain)\n  return(mcmc.chain)\n}\n\nmcmc.mh <- function(y, mcmc.niters=1e4)\n{\n  # Complete with MH.\n  S = sum(y)\n  n = length(y)\n  mcmc.chain <- matrix(0.1, nrow=mcmc.niters, ncol=2)\n  nacc <- 0\n  for(i in 2:mcmc.niters)\n  {\n    mu <- rgamma.trunc(kBound**2, s=S+1, r=n)\n    # 1. Current state\n    alpha.old = mcmc.chain[i-1, 1]\n    beta.old = mcmc.chain[i-1, 2]\n    # 2. Propose new state\n    #   Respect symmetry in (a,b)\n    alpha.new = runif(1, min=mu/kBound, max=kBound)\n    beta.new = mu / alpha.new\n    if(runif(1) < 0.5)\n    {\n      beta.new = alpha.new\n      alpha.new = mu / beta.new\n    }\n    # 3. Ratio\n    mh.ratio = min(0, log.posterior(alpha.new, beta.new, y) - \n                     log.posterior(alpha.old, beta.old, y))\n    if(runif(1) < exp(mh.ratio)) {\n      # Accept \n      mcmc.chain[i, ] <- c(alpha.new, beta.new)\n      nacc <- nacc + 1\n    } else {\n      mcmc.chain[i, ] <- c(alpha.old, beta.old)\n    }\n  }\n  # Cut the burnin period.\n  print(sprintf(\"Acceptance ratio %.2f%%\", 100 * nacc / mcmc.niters))\n  plot.chain(mcmc.chain)\n  return(mcmc.chain)\n}\n\ny = sample.data(100)\nplot.posterior.density(y) \n\n\nout = mcmc.gibbs(y, mcmc.niters=1e5)\n\nout = mcmc.mh(y, mcmc.niters=1e5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1414773996832.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1504865611",
    "id" : "B6B46ABD",
    "lastKnownWriteTime" : 1414894190,
    "path" : "~/Documents/School/Harvard/Third Semester/STAT 221/Assignments/Ass4/Ass4 R Code/mcmc.R",
    "project_path" : "mcmc.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}