{
    "contents" : "#1.4\nlibrary(MASS)\nlibrary(coda)\n\nimpala = read.table(\"impala.txt\", header = TRUE)\nimpala = impala[,1]\n\nwaterbuck = read.table(\"waterbuck.txt\", header = TRUE)\nwaterbuck = waterbuck[,1]\n\nkBound = 150\nkMu = 5\nkTheta = 0.6\nkLambda = kTheta * kMu\n\nsample.data <- function(n)\n{\n  N = rpois(1,kMu)\n  Y = rbinom(n, N, kTheta)\n}\n\nlog.lik <- function(Y, N, theta)\n{\n  # Log-likelihood of the data\n  sum(dbinom(Y, N, theta, log=T))\n}\n\nlog.prior <- function(N, theta)\n{\n  #1/N times the indicator that theta is in [0,1]\n  log(1/N * ifelse(theta>=0 & theta<=1,1,0))\n}\n\nlog.posterior <- function(Y, N, theta)\n{\n  log.lik(Y, N, theta) + log.prior(N, theta)\n}\n\nmle <- function(y)\n{\n  # Example code to compute the MLE given the data\n  # \n  # Args:\n  #   y = vector of values (generated by sample.data)\n  # Example:\n  #   y = sample.data(100)\n  #   mle(y)\n  f <- function(par)\n  {\n    #adds floor function since N must be a positive integer\n    log.lik(y, floor(par[1]), par[2])\n  }\n  x = optim(par=c(max(y),0.5), fn=f, control=list(fnscale=-1),\n            method=\"L-BFGS-B\", lower=c(max(y), 1e-10), upper = c(Inf,1-1e-10))\n  print(sprintf(\"Log-likelihood=%.3f\", x$value))\n  return(x$par)\n}\n\n\nplot.posterior.density <- function(data, overlay=FALSE, graph.length=200)\n{\n  # Plots the density of the posterior density with contour lines.\n  #\n  # Args:\n  #   data = vector of values (generated by sample.data)\n  # Example:\n  #   y = sample.data(100)\n  #   explore.posterior.density(y)\n  N = seq(max(data), max(data)+graph.length, by=1)\n  theta = seq(0,1,length.out=length(N)+2)\n  theta = theta[-length(theta)][-1]\n  gr = expand.grid(x=N, y=theta)\n  z = apply(gr, 1, function(par) log.lik(data, par[1], par[2]))\n  z = matrix(z, nrow=length(N), ncol=length(theta))\n  print(\"Summary of likelihood values.\")\n  print(summary(exp(as.vector(z))))\n  z0 = quantile(z, probs = c(0.1))\n  z1 = max(z)\n  ncols = 10000\n  cols = topo.colors(ncols)\n  i = apply(gr, 1, function(par) {\n    ll = log.posterior(data, par[1], par[2])\n    if(ll < z0) return(0)\n    return((ll - z0) / (z1 - z0))\n  })\n  par(mfrow=c(1, 1))\n  # hist(i)\n  j = ncols * i\n  j[j==0] <- 1\n  if(overlay==FALSE)\n    plot(gr[,1], gr[,2], xlab=\"N\", ylab=\"theta\", col=cols[j], pch=\".\", cex=4)\n  contour(N, theta, z, nlevels = 50, add=T, cex=2, col=\"black\")\n}\n\nexplore.log.lik <- function(data, ndraws=1e4)\n{\n  # Simply tries random values for (a, b) and computes the likelihood.\n  #\n  random.par <- function()\n  {\n    return(runif(2, min=1e-4, max=20))\n  }  \n  mPar = t(replicate(ndraws, { random.par() }))\n  z = apply(mPar, 1, function(row) log.lik(row[1], row[2], data))\n  mPar = cbind(mPar, z)\n  # order by increasing likelihood\n  mPar = mPar[rev(order(z)), ]\n}\n\nplot.chain <- function(mcmc.chain)\n{\n  mcmc.niters = nrow(mcmc.chain)\n  burnin = 0.1 * mcmc.niters\n  mcmc.chain = mcmc.chain[burnin:mcmc.niters, ]\n  f = kde2d(x=mcmc.chain[, 1], y=mcmc.chain[, 2], n=100)\n  image(f, xlim=range(mcmc.chain[,1]), ylim=range(mcmc.chain[,2]), xlab=\"N\", ylab=\"theta\")\n}\n\n\nmcmc.mh <- function(y, mcmc.niters=1e4, N.bound, N.init, theta.init)\n{\n  # Complete with MH.\n  S = sum(y)\n  n = length(y)\n  mcmc.chain <- matrix(, nrow=mcmc.niters, ncol=2)\n  mcmc.chain[1,]=c(N.init, theta.init)\n  nacc <- 0\n  for(i in 2:mcmc.niters)\n  {\n    # 1. Current state\n    N.old = mcmc.chain[i-1, 1]\n    theta.old = mcmc.chain[i-1, 2]\n    # 2. Propose new state\n    #Sample new N\n    repeat\n    {      \n      #geometric over entire thing\n        N.new = rgeom(1,1/(1+N.old))\n      #only keep sample if N is in the boundaries\n      if(N.new >= max(y) & N.new<=N.bound)\n        break\n    }\n    #Sample new NTheta, then infer new theta\n    repeat\n    {\n      #sample theta from Beta\n      M.new = N.old * rbeta(1, shape1 = S+1, shape2 = n*N.old-S+1)\n      theta.new = M.new/N.new\n      #only keep theta if it is valid\n      if(theta.new>=0 && theta.new<=1)\n        break\n    }\n    \n    # 3. Ratio\n    mh.ratio = min(0, log.posterior(y,N.new,theta.new) - \n                     log.posterior(y,N.old,theta.old))\n    if(runif(1) < exp(mh.ratio)) {\n      # Accept \n      mcmc.chain[i, ] <- c(N.new, theta.new)\n      nacc <- nacc + 1\n    } else {\n      mcmc.chain[i, ] <- c(N.old, theta.old)\n    }\n  }\n  # Cut the burnin period.\n  print(sprintf(\"Acceptance ratio %.2f%%\", 100 * nacc / mcmc.niters))\n  plot.chain(mcmc.chain)\n  return(list(\"chain\"=mcmc.chain, \"accept\" = 100 * nacc / mcmc.niters))\n}\n\ny = waterbuck\nparam = cbind(c(rep(max(y),5), rep(max(y)+10,5)),c(rep(c(0.1,0.3,0.5,0.7,0.9),2)))\n#prob that N>100\nwaterbuck.prob=c()\nfor(i in 1:10)\n{\n  waterbuck.sample = mcmc.mh(y, mcmc.niters=1e5, N.bound=200, N.init=param[i,1], theta.init=param[i,2])  \n  N = waterbuck.sample$chain[,1]\n  theta = waterbuck.sample$chain[,2]\n  burnin = length(N)*0.1\n  N = N[burnin:length(N)]\n  theta = theta[burnin:length(theta)]\n  \n  png(paste(\"Stat221Waterbuck\",i,\".png\",sep=\"\"), width = 600, height = 400)\n  par(mar=c(5,5,3,3))\n  plot(N,theta,main=paste(sep=\"\",\"N=\",param[i,1], \"  theta=\",param[i,2]),cex.main=3,cex.lab=2.5,cex.axis=2)\n  plot.posterior.density(y,overlay=TRUE,graph.length=200)\n  dev.off()\n  waterbuck.prob[i] = length(which(N>100))/length(N)\n}\n\npng(paste(\"Stat221WaterbuckDiag.png\"),width=600,height=600)\npar(mfrow=c(2,2))\nacf(N, main=\"ACF for N\")\nacf(theta, main=\"ACF for theta\")\nplot(N,type='l',main=\"Traceplot for N\")\nplot(theta,type='l',main=\"Traceplot for theta\")\ndev.off()\n\ny = impala\nparam = cbind(c(rep(max(y),5), rep(max(y)+10,5)),c(rep(c(0.1,0.3,0.5,0.7,0.9),2)))\n#prob that N>100\nimpala.prob=c()\nfor(i in 1:10)\n{\n  impala.sample = mcmc.mh(y, mcmc.niters=1e5, N.bound=200, N.init=param[i,1], theta.init=param[i,2])  \n  N = impala.sample$chain[,1]\n  theta = impala.sample$chain[,2]\n  burnin = length(N)*0.1\n  N = N[burnin:length(N)]\n  theta = theta[burnin:length(theta)]\n  \n  png(paste(\"Stat221Impala\",i,\".png\",sep=\"\"), width = 600, height = 400)\n  plot(N,theta,main=paste(sep=\"\",\"N=\",param[i,1], \"  theta=\",param[i,2]),cex.main=3,cex.lab=2.5,cex.axis=2)\n  plot.posterior.density(y,overlay=TRUE,graph.length=200)\n  dev.off()\n  impala.prob[i] = length(which(N>100))/length(N)\n}\n\npng(paste(\"Stat221ImpalaDiag.png\"),width=600,height=600)\npar(mfrow=c(2,2))\nacf(N)\nacf(theta)\nplot(N,type='l',main=paste(\"N \", impala.sample$accept, \"%\"))\nplot(theta,type='l',main=\"theta\")\ndev.off()\n\n\n",
    "created" : 1414892089283.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3214825757",
    "id" : "3CC87AC2",
    "lastKnownWriteTime" : 1415142944,
    "path" : "~/Documents/School/Harvard/Third Semester/STAT 221/Assignments/Ass4/Ass4 R Code/tam_gregory_mcmc.R",
    "project_path" : "tam_gregory_mcmc.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}