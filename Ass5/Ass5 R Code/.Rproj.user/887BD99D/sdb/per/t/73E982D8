{
    "contents" : "library(MASS) #ginv\ndat = read.csv(\"2router_linkcount.dat\")\nattach(dat)\n\nstart_time=Sys.time()\n\ntask.id = as.numeric(Sys.getenv(\"SLURM_ARRAY_TASK_ID\"))\njob.id = as.numeric(Sys.getenv(\"SLURM_ARRAY_JOB_ID\"))\n\ny = matrix(value[which(nme %in% nme[1:16])],nrow=16)\n\n\n\n#set A matrix\nI=64\nJ=16\nc=2\nT=length(nme)/16\nA = matrix(,nrow=J-1,ncol=I)\nrownames(A) = c(\"router5\",\"r4-local\",\"switch\",\"r4-others\",\"gw1\",\"gw2\",\"gw3\",\"gw-others\",\"router5\",\"r4-local\",\"switch\",\"r4-others\",\"gw1\",\"gw2\",\"gw3\")\nA[1,]=c(rep(1,8),rep(0,56))\nA[2,]=c(rep(0,8),rep(1,8),rep(0,48))\nA[3,]=c(rep(0,16),rep(1,8),rep(0,40))\nA[4,]=c(rep(0,24),rep(1,8),rep(0,32))\nA[5,]=c(rep(0,32),rep(1,8),rep(0,24))\nA[6,]=c(rep(0,40),rep(1,8),rep(0,16))\nA[7,]=c(rep(0,48),rep(1,8),rep(0,8))\nA[8,]=c(rep(0,56),rep(1,8))\nA[9,]=rep(c(1,0,0,0,0,0,0,0),4)\nA[10,]=rep(c(0,1,0,0,0,0,0,0),4)\nA[11,]=rep(c(0,0,1,0,0,0,0,0),4)\nA[12,]=rep(c(0,0,0,1,0,0,0,0),4)\nA[13,]=rep(c(0,0,0,0,1,0,0,0),4)\nA[14,]=rep(c(0,0,0,0,0,1,0,0),4)\nA[15,]=rep(c(0,0,0,0,0,0,1,0),4)\n\nftest = function(theta,a,b,c)\n{\n  #the function f which we try to set to 0\n  #takes theta as input, returns f(theta) vector\n  ans = c()\n  lambda = head(theta,length(theta)-1)\n  phi = tail(theta,1)\n  for(i in 1:length(theta))\n  {\n    if(i<=I)\n      ans[i] = c*phi*lambda[i]^c + (2-c)*lambda[i]^2 - 2*(1-c)*lambda[i]*b[i] - c*a[i]\n    if(i==I+1)\n      ans[i] = sum(lambda^(-c+1)*(lambda - b))\n  }\n  ans\n}\n\n#############\n#LOCAL MODEL#\n#############\n\nlocally_iid_EM = function(data, c, A, lambda.init = 1e6, phi.init=0.5)\n{\n  w=11\n  h=(w-1)/2\n  T=length(nme)/16\n  #initialize the theta vector for simplicity, keep all lambdas the same. \n  #choice of these parameters are important. I initially had small lambdas, and\n  #the EM would not work.\n  lambda = rep(lambda.init,64)\n  phi = phi.init\n  theta = matrix(c(lambda,phi),ncol=1)\n  \n  f.array = matrix(,ncol=0,nrow=I+1)\n  #replicate for each t\n  for(t in 6:(T-5))\n  {\n    #previous theta vector (lambda, phi)\n    theta.old = theta[,ncol(theta)]\n    theta.new=c()\n    \n    #E-step\n    Sigma = diag(phi*lambda^c)\n    min.t = t-h\n    max.t = t+h\n    m = sapply(min.t:max.t, function(i) lambda + Sigma %*% t(A) %*% ginv(A %*% Sigma %*% t(A)) %*% (data[-16,i] - A %*% lambda))\n    R = Sigma - Sigma %*% t(A) %*% ginv(A %*% Sigma %*% t(A)) %*% A %*% Sigma\n    \n    #finds f, which is the derivative of Q(theta,theta^{(t)})\n    #Newton-Raphson is done on f to find the maximum of Q   \n    a=c()\n    b=c()\n    f=c()\n    for(i in 1:I)\n    {\n      a[i] = R[i,i] + mean(m[i,]^2)\n      b[i] = mean(m[i,])\n      f[i] = c*phi*lambda[i]^c + (2-c)*lambda[i]^2 - 2*(1-c)*lambda[i]*b[i] - c*a[i]\n    }\n    f[I+1] = sum(lambda^(-c+1)*(lambda - b))\n    \n    \n    #analytical solution: when c=2, it sets the lambda such that f()=0\n    lambda = (-b + sqrt(b^2 + 4*a*phi))/(2*phi)\n    #replace lambdas with analytical solutions\n    theta.new[1:I] = lambda\n    #check that f is close to 0\n    ftest(c(lambda,phi),a,b,c)\n    \n    #M-step\n    \n    #Create Fdot matrix (derivative)\n    Fdot = matrix(,nrow=I+1,ncol=I+1)\n    for(i in 1:I)\n      for(j in 1:I)\n        Fdot[i,j] = (i==j)*(phi*c^2*lambda[i]^(c-1) + 2*(2-c)*lambda[i] - 2*(1-c)*b[i])\n    for(j in 1:I)\n      Fdot[I+1,j] = (2-c)*lambda[j]^(1-c) - (1-c)*lambda[j]^(-c)*b[j]\n    for(i in 1:I)\n      Fdot[i,I+1] = c*lambda[i]^c\n    Fdot[I+1,I+1] = 0\n    \n    mult=1\n    tempInv = ginv(Fdot) %*% f\n    repeat\n    {\n      #Fractional Newton-Raphson: Shrinks amount it takes off to ensure phi remains greater than 0\n      phi = theta.old[I+1] - mult*tempInv[I+1,]\n      if(phi>0)\n        break\n      mult = mult/2\n    }\n    theta.new[I+1] = phi\n    ftest(c(lambda,phi),a,b,c)\n    \n    theta.old = theta.new\n    theta = cbind(theta,theta.new)\n    f.array = cbind(f.array,ftest(theta.new,a,b,c))\n  }\n  list(\"f\"=f.array,\"theta\"=theta,\"a\"=a,\"b\"=b)\n}\n\n#aggregated ftest: Since ftest is a vector, we take the sum of square since we want to minimize it\noptim_ftest = function(theta,a,b,c){sum(ftest(theta,a,b,c)^2)}\nSys.time()\nf_em = locally_iid_EM(y,c,A,lambda.init=temp)\nf_em$f\n\n\nend_time = Sys.time()\ntotal_time = as.numeric(end_time-start_time,units=\"mins\")\nsave(list = c(\"f_em\",\"start_time\",\"end_time\",\"total_time\",\"last_par\"), file=sprintf(\"odyssey/pset5/converge_task%d_job%d.rda\", task.id, job.id))\n\n\n#T-10 columns since we ignore the first 5 and last 5 (window size)\n#ignore the first entry of theta (the -1 term) since that is our initial value.\n#To find this we look at the matrix A and see which plots correspond to columns of A\ntheta.MA = matrix(,nrow=81,ncol=T-10)\n\ntheta.MA[10:17,] = f_em$theta[13:16,-1]\ntheta.MA[9+10:17,] = f_em$theta[9:12,-1]\ntheta.MA[9*2+10:17,] = f_em$theta[5:8,-1]\ntheta.MA[9*3+10:17,] = f_em$theta[1:4,-1]\ntheta.MA[9*4+10:17,] = f_em$theta[13:16,-1]\ntheta.MA[9*5+10:17,] = f_em$theta[9:12,-1]\ntheta.MA[9*6+10:17,] = f_em$theta[5:8,-1]\ntheta.MA[9*7+10:17,] = f_em$theta[1:4,-1]\n\n#fill in other boxes with appropriate sums\ntheta.MA[1,] = apply(theta.MA[1+seq(9,72,9),],2,sum)\ntheta.MA[2,] = apply(theta.MA[2+seq(9,72,9),],2,sum)\ntheta.MA[3,] = apply(theta.MA[3+seq(9,72,9),],2,sum)\ntheta.MA[4,] = apply(theta.MA[4+seq(9,72,9),],2,sum)\ntheta.MA[5,] = apply(theta.MA[5+seq(9,72,9),],2,sum)\ntheta.MA[6,] = apply(theta.MA[6+seq(9,72,9),],2,sum)\ntheta.MA[7,] = apply(theta.MA[7+seq(9,72,9),],2,sum)\ntheta.MA[8,] = apply(theta.MA[8+seq(9,72,9),],2,sum)\n\ntheta.MA[18,] = apply(theta.MA[18-8:1,],2,sum)\ntheta.MA[27,] = apply(theta.MA[27-8:1,],2,sum)\ntheta.MA[36,] = apply(theta.MA[36-8:1,],2,sum)\ntheta.MA[45,] = apply(theta.MA[45-8:1,],2,sum)\ntheta.MA[54,] = apply(theta.MA[54-8:1,],2,sum)\ntheta.MA[63,] = apply(theta.MA[63-8:1,],2,sum)\ntheta.MA[72,] = apply(theta.MA[72-8:1,],2,sum)\ntheta.MA[81,] = apply(theta.MA[80-8:1,],2,sum)\n\ntheta.MA[9,] = apply(theta.MA[c(10:17,19:26,28:35,37:44,46:53,55:62,64:71,73:79),],2,sum)\n\n\n#Plot actual data\ndev.off()\npdf(\"tam_gregory_fig6_2routerlocal.pdf\",width=9,height=9)\npar(mfrow=c(9,9),oma=c(1.5,1.5,1.5,1.5))\npar(mar=c(2.5,2.5,1,0))\nname.list = c(\"dst router5\", \"dst r4-local\", \"dst switch\", \"dst r4-others\",\"dst gw1\", \"dst gw2\", \"dst gw3\", \"dst gw-others\", \n              \"ori router5\", \"ori r4-local\", \"ori switch\", \"ori r4-others\",\"ori gw1\", \"ori gw2\", \"ori gw3\", \"ori gw-others\")\nplotted.values = matrix(,nrow=81,ncol=T)\n\n#stores indices of destimation and origin values so we know for which values of i to plot\nindex_vec = c(1:8,seq(18,81,9))\nfor(i in 1:81)\n{\n  if(i %in% index_vec)\n  {\n    indices = which(nme == name.list[which(index_vec==i)])\n    plotted.values[i,]=value[indices]\n    if(i==1)\n    {\n      plot(plotted.values[i,],type='l',ylim=range(0,1e6),xaxt=\"n\",main=name.list[which(index_vec==i)],lwd=2,col=\"cyan\")\n    }else if(i==81)\n    {\n      plot(plotted.values[i,],type='l',ylim=range(0,1e6),yaxt=\"n\",main=name.list[which(index_vec==i)],lwd=2,col=\"cyan\")\n    }else\n    {\n      plot(plotted.values[i,],type='l',ylim=range(0,1e6),xaxt=\"n\",yaxt=\"n\",main=name.list[which(index_vec==i)],lwd=2,col=\"cyan\")\n    }\n  }else if(i==73) #bottom left corner\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),main=name.list[i],lwd=2,col=\"cyan\")\n  }else if(i>73) #bottom row\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),yaxt=\"n\",lwd=2,col=\"cyan\")\n  }else if(i%%9==1) #left side\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),xaxt=\"n\",lwd=2,col=\"cyan\")\n  }else #everything else (no axis labels)\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),xaxt=\"n\",yaxt=\"n\",lwd=2,col=\"cyan\")\n  }\n  #Plot fitted data\n  lines(1:278+5,theta.MA[i,],lwd=2)\n}\nmtext(\"Local Observation\",outer=TRUE)\nmtext(\"Bytes/sec\",outer=TRUE,side=2)\nmtext(\"Hour of Day\",outer=TRUE,side=1)\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n################\n#SMOOTHED MODEL#\n################\n\nsmoothed_EM = function(data,c,A,V.init,eta.init)\n{\n  I=ncol(A)\n  J=nrow(A)+1\n  c=2\n  \n  #Step 1 (Set initial parameters)\n  h=5\n  w=2*h+1\n  t=h+1\n  eta = matrix(rep(eta.init,65),nrow=65,ncol=1)\n  V = diag(rep(V.init,65))\n  f.array = matrix(,ncol=0,nrow=I+1)\n  \n  \n  #Step 2\n  for(t in 6:(T-5))\n  {\n    eta.hat.old = eta[,ncol(eta)]\n    eta.hat.new = c()\n    \n    #E-step\n    #set lambda and phi based on eta\n    lambda = exp(head(eta.hat.old,length(eta.hat.old)-1))\n    phi = exp(tail(eta.hat.old,1))\n    \n    Sigma.full = diag(c(phi*lambda^c, phi))\n    Sigma = diag(phi*lambda^c)\n    min.t = t-h\n    max.t = t+h\n    m = sapply(min.t:max.t, function(i) lambda + Sigma %*% t(A) %*% ginv(A %*% Sigma %*% t(A)) %*% (data[-16,i] - A %*% lambda))\n    R = Sigma - Sigma %*% t(A) %*% ginv(A %*% Sigma %*% t(A)) %*% A %*% Sigma\n    \n    Q.local = -w/2*(log(det(Sigma))) + tr(ginv(Sigma) %*% R) - 1/2*sum(sapply(1:11,function(i) t(m[,i]-lambda) %*% ginv(Sigma) %*% (m[,i]-lambda)))  \n    Q.prior = function(eta.val)\n    {\n      eta.hat.old\n      Sigma.hat = Sigma.full + V\n      dmvnorm(eta.val, mean=eta.hat.old, sigma=Sigma.hat, log=TRUE)\n    }\n    g = function(eta.val){Q.local + Q.prior(eta.val)}\n    \n    #Find mode of g\n    #Optimizing over all eta's at once doesn't work, so we do it termwise\n    g.marginal = function(eta.change, eta.val,index)\n    {\n      #eta.change: eta coordinate we change\n      #index: index for eta.change\n      #eta.val: vector of etas\n      eta.val[index]=eta.change\n      g(eta.val)\n    }\n    \n    eta.hat.new=eta.hat.old\n    eta.hat.new[1] = optim(1, g.marginal, eta.val=eta.hat.old, index=1, control=list(fnscale=-1),method=\"Brent\",lower=1.0001,upper=1e7)$par\n    for(reps in 1:20)\n    {\n      for(i in 1:17)\n      {\n        eta.hat.new[i] = optim(eta.hat.new[i], g.marginal, eta.val=eta.hat.new, index=i, control=list(fnscale=-1),method=\"Brent\",lower=1.0001,upper=1e7)$par\n      }\n    }\n    eta.hat.old = eta.hat.new\n    eta = cbind(eta,eta.hat.new)\n    f.array = cbind(f.array,exp(dlogprior(head(eta.hat.new,length(eta.hat.new)-1),head(eta.hat.old,length(eta.hat.old)-1),Sigma) + dloglikelihood(t(data[-8,t]),A,lambda,Sigma)))\n    print(paste(\"Step\",t))\n  }\n  list(\"f\"=f.array,\"eta\"=eta, \"theta\"=exp(eta))\n}\n\n\n\n\n\nf_em2 = smoothed_EM(y,c,A,V.init=5,eta.init=3)\nf_em2$f\n\n\nend_time = Sys.time()\ntotal_time = as.numeric(end_time-start_time,units=\"mins\")\nsave(list = c(\"f_em\",\"start_time\",\"end_time\",\"total_time\",\"last_par\"), file=sprintf(\"odyssey/pset5/converge_task%d_job%d.rda\", task.id, job.id))\n\n\n#T-10 columns since we ignore the first 5 and last 5 (window size)\n#ignore the first entry of theta (the -1 term) since that is our initial value.\n#To find this we look at the matrix A and see which plots correspond to columns of A\ntheta.MA = matrix(,nrow=81,ncol=T-10)\n\ntheta.MA[10:17,] = f_em2$theta[13:16,-1]\ntheta.MA[9+10:17,] = f_em2$theta[9:12,-1]\ntheta.MA[9*2+10:17,] = f_em2$theta[5:8,-1]\ntheta.MA[9*3+10:17,] = f_em2$theta[1:4,-1]\ntheta.MA[9*4+10:17,] = f_em2$theta[13:16,-1]\ntheta.MA[9*5+10:17,] = f_em2$theta[9:12,-1]\ntheta.MA[9*6+10:17,] = f_em2$theta[5:8,-1]\ntheta.MA[9*7+10:17,] = f_em2$theta[1:4,-1]\n\n#fill in other boxes with appropriate sums\ntheta.MA[1,] = apply(theta.MA[1+seq(9,72,9),],2,sum)\ntheta.MA[2,] = apply(theta.MA[2+seq(9,72,9),],2,sum)\ntheta.MA[3,] = apply(theta.MA[3+seq(9,72,9),],2,sum)\ntheta.MA[4,] = apply(theta.MA[4+seq(9,72,9),],2,sum)\ntheta.MA[5,] = apply(theta.MA[5+seq(9,72,9),],2,sum)\ntheta.MA[6,] = apply(theta.MA[6+seq(9,72,9),],2,sum)\ntheta.MA[7,] = apply(theta.MA[7+seq(9,72,9),],2,sum)\ntheta.MA[8,] = apply(theta.MA[8+seq(9,72,9),],2,sum)\n\ntheta.MA[18,] = apply(theta.MA[18-8:1,],2,sum)\ntheta.MA[27,] = apply(theta.MA[27-8:1,],2,sum)\ntheta.MA[36,] = apply(theta.MA[36-8:1,],2,sum)\ntheta.MA[45,] = apply(theta.MA[45-8:1,],2,sum)\ntheta.MA[54,] = apply(theta.MA[54-8:1,],2,sum)\ntheta.MA[63,] = apply(theta.MA[63-8:1,],2,sum)\ntheta.MA[72,] = apply(theta.MA[72-8:1,],2,sum)\ntheta.MA[81,] = apply(theta.MA[80-8:1,],2,sum)\n\ntheta.MA[9,] = apply(theta.MA[c(10:17,19:26,28:35,37:44,46:53,55:62,64:71,73:79),],2,sum)\n\n\n#Plot actual data\ndev.off()\npdf(\"tam_gregory_fig6_2router.pdf\",width=9,height=9)\npar(mfrow=c(9,9),oma=c(1.5,1.5,1.5,1.5))\npar(mar=c(2.5,2.5,1,0))\nname.list = c(\"dst router5\", \"dst r4-local\", \"dst switch\", \"dst r4-others\",\"dst gw1\", \"dst gw2\", \"dst gw3\", \"dst gw-others\", \n              \"ori router5\", \"ori r4-local\", \"ori switch\", \"ori r4-others\",\"ori gw1\", \"ori gw2\", \"ori gw3\", \"ori gw-others\")\nplotted.values = matrix(,nrow=81,ncol=T)\n\n#stores indices of destimation and origin values so we know for which values of i to plot\nindex_vec = c(1:8,seq(18,81,9))\nfor(i in 1:81)\n{\n  if(i %in% index_vec)\n  {\n    indices = which(nme == name.list[which(index_vec==i)])\n    plotted.values[i,]=value[indices]\n    if(i==1)\n    {\n      plot(plotted.values[i,],type='l',ylim=range(0,1e6),xaxt=\"n\",main=name.list[which(index_vec==i)],lwd=2,col=\"cyan\")\n    }else if(i==81)\n    {\n      plot(plotted.values[i,],type='l',ylim=range(0,1e6),yaxt=\"n\",main=name.list[which(index_vec==i)],lwd=2,col=\"cyan\")\n    }else\n    {\n      plot(plotted.values[i,],type='l',ylim=range(0,1e6),xaxt=\"n\",yaxt=\"n\",main=name.list[which(index_vec==i)],lwd=2,col=\"cyan\")\n    }\n  }else if(i==73) #bottom left corner\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),main=name.list[i],lwd=2,col=\"cyan\")\n  }else if(i>73) #bottom row\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),yaxt=\"n\",lwd=2,col=\"cyan\")\n  }else if(i%%9==1) #left side\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),xaxt=\"n\",lwd=2,col=\"cyan\")\n  }else #everything else (no axis labels)\n  {\n    plot(-1,type='l',xlim=range(1,288),ylim=range(0,1e6),xaxt=\"n\",yaxt=\"n\",lwd=2,col=\"cyan\")\n  }\n  #Plot fitted data\n  lines(1:278+5,theta.MA[i,],lwd=2)\n}\nmtext(\"Smoothed Observation\",outer=TRUE)\nmtext(\"Bytes/sec\",outer=TRUE,side=2)\nmtext(\"Hour of Day\",outer=TRUE,side=1)\ndev.off()\n\n",
    "created" : 1416537963662.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3726586278",
    "id" : "73E982D8",
    "lastKnownWriteTime" : 1416535284,
    "path" : "~/Documents/School/Harvard/Third Semester/STAT 221/Assignments/Ass5/Ass5 R Code/tam_gregory_ps5_1.9.R",
    "project_path" : "tam_gregory_ps5_1.9.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}